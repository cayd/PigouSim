from SimianPie.simian import Simian, Entity

import matplotlib.pyplot as plt
from matplotlib import collections
from math import *
import random

#minDelay equates to a second
simName, startTime, endTime, minDelay, useMPI = "GRID", 0, 24, 1.0/3600.0, False


#consumption function is in the form of f(Theta)=-Asin(pi/12 Theta)+Fi, with the further simplification that A = Fi/3

#        ID    Location(lat, lon)     String ID(name)    Population in millions   State   priceCurve (explanation in Producer)
grid =  [[1,   [32.7150, 117.1625],   "San Diego",       1.356,                   "CA",      .5],
         [2,   [34.0500, 118.2500],   "Los Angeles",     18.55,                   "CA",      .5],
         [3,   [38.5556, 121.4689],   "Sacramento",      .48,                     "CA",      .5],
         [4,   [37.7833, 122.4167],   "San Francisco",   .837,                    "CA",      .5],
         [5,   [41.8369, 87.6847],    "Chicago",         2.719,                   "IL",      .5],
         [6,   [42.3314, 83.0458],    "Detroit",         .689,                    "MI",      .5],
         [7,   [42.3601, 71.0589],    "Boston",          .646,                    "MA",      .5],
         [8,   [25.7753, 80.2089],    "Miami",           .418,                    "FL",      .5],
         [9,   [40.7127, 74.0059],    "New York",        8.406,                   "NY",      .5],
         [10,  [39.8333, 97.4167],    "CENTER",          0,                       "US",      .5]]

#              Voltage    Points connected by lines of such voltage
connections = [[2000,     (1,2), (1,3), (7,9), (9,5), (9,2)],
               [1000,     (2,3), (5,6), (9,8)],
               [500,      (1,4)]]              
                 
perCapita = {"US":12146,#kWh/capita in 2010
             "WY":27457, 
             "KY":21590, 
             "ND":19477,
             "LA":18852,
             "SC":17903,
             "AL":17293,
             "WV":17290,
             "MS":16793,
             "AR":16519,
             "IN":16315,
             "NE":16293,
             "TN":16117,
             "OK":15568,
             "IA":15048,
             "GA":14578,
             "VA":14489,
             "ID":14475,
             "MO":14345,
             "NC":14325,
             "KS":14263,
             "TX":14179,
             "MT":13992,
             "SD":13916,
             "WA":13557,
             "OH":13388,
             "DE":12904,
             "MN":12845,
             "NV":12497,
             "FL":12379,
             "WI":12159,
             "OR":12077,
             "PA":11759,
             "AZ":11395,
             "MD":11343,
             "IL":11253,
             "NM":10739,
             "MI":10516,
             "CO":10359,
             "UT":10106,
             "NJ":8985,
             "VT":8982,
             "ME":8696,
             "MA":8591,
             "CT":8514,
             "NH":8286,
             "NY":7467,
             "RI":7434,
             "CA":6721}

citiesList = []
# If you use the curve from california you can fit it to be approx. sinusoidal. Then all you need is the average demand around which you oscillate and some idea of amplitude.
# The period and the horizontal shift will remain constant
 
#distance maybe?
def greatCircle(lat1, lon1, lat2, lon2):  
    # convert decimal degrees to radians
    # haversine formula 
    dlat = lat2 - lat1
    dlon = lon2 - lon1  
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * asin(sqrt(a)) 
    r = 6371 # Radius of earth in kilometers. Use 3956 for miles
    return c * r *1000
    
#straightforward
def getIndex(Id):
    for i in range(len(grid)):
        if grid[i][0] == Id:
            return i
            
#straightforward
def getName(line):
    return line[2]
    
#returns poulation
def getPop(line):
    return line[3]
    
#returns the state of the city 
def getState(line):
    return line[4]
    
#returns priceCurve
def getPriceCurve(line):
    return line[5]
            
#everything will work off the line of the database passed in
def getCoords(line):
    lat1, lon1 = 39.8333, 97.4167 #the approx. center of the continental U.S.
    lat2, lon2 = line[1][0], line[1][1]
    #decimal to radian
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    #calls another function to find distance
    distance = greatCircle(lat1, lon1, lat2, lon2)
    #the math for bearing
    varY = sin(lon2-lon1)*cos(lat2)
    varX = cos(lat1) * sin(lat2) - sin(lat1)*cos(lat2)*cos(lon2-lon1)
    bearing = atan2(varY, varX)
    #converts to measure up from the X-axis instead of down east from true North
    quadrantBearing = ((2*pi)-bearing+(pi/2))%(2*pi)
    #polar to xy 
    xCoord = -1*distance*cos(quadrantBearing)
    yCoord = distance*sin(quadrantBearing)
    return xCoord, yCoord

#the cute little graph
def graph():
    fig = plt.figure()
    ax = fig.add_subplot(111)

    lines = []

    #loops through lines that contain points
    for i in grid: 
        #makes a tuple coorinate pair for the point
        var = getCoords(i)
        #plots the point
        ax.scatter(var[0], var[1])
        #labels the point
        ax.annotate(getName(i), xy=var)

    #creates the list of lines to draw between points
    for i in connections:
        i.pop(0)
        temp = []
        for j in i:
            temp.append([getCoords(grid[getIndex(j[0])]), getCoords(grid[getIndex(j[1])])])
        lines.append(temp)      

    #plots the connecting line segments, for each change in voltage, changes the color. NOTE: does not sort voltages, only goes down the list
    a = 1
    for i in lines:
        lc = collections.LineCollection(i, colors=(0,1/a,0,1), linewidths=2)
        ax.add_collection(lc)
        a += .5

    plt.gca().set_aspect('equal')
    ax.autoscale()
    plt.show()


#The producer Entity
#eventually we'll treat this as an individual, even though it's really all natural gas or whatever firms in the market. so it will need marginal revenue and cost curves: CM
class Producer(Entity):
    def __init__(self, baseInfo, line):
        super(Producer, self).__init__(baseInfo)
        self.line = line
        self.name = getName(line)
        self.pop = getPop(line)
        # the slope of a line that more or less functions as a predictor of output based on price
        # form: kW output = priceCurve * price of power, where priceCurve is currently hardcoded to .5: CM
        self.priceCurve = getPriceCurve(line)
        self.outputList = []
        self.output = 0
        self.out.write("Time " + str(self.engine.now) + ": Creating " + self.name + " Producer\n")

    
    #finds outputList as just what we predicted it to be from the sin function; at some point add a little to every point so that you overproduce power and dont leave anyone without
    def receiveConsumptionPrediction(self, predictionsList, *args):
        self.outputList = predictionsList
        self.out.write("Time " + str(self.engine.now) + ": receiveConsumptionPrediction occuring at " + self.name + " Producer\n")

        
    #sends to the city, which will form a local net and send to the gridmaster
    def sendProduction(self, *args):
        self.reqService(minDelay, "receiveProduction", self.output, self.name+"City", 1)
        self.out.write("Time " + str(self.engine.now) + ": sendProduction occuring at " + self.name + " Producer\n")


        
#The city Entity, a combination of city and consumer that serves as the primary reference for all geographically local happenings
class City(Entity):
    def __init__(self, baseInfo, line):
        super(City, self).__init__(baseInfo)
        self.line = line
        self.name = getName(line)
        #this list is the expected draw of the city, with the indexes as the time that draw is expected, e.g. expectedPowerDraw[1] = (expected draw at hour 1)
        self.expectedPowerDraw = []
        self.powerDraw = self.updateDraw(self.engine.now)###### find the right statement for this
        self.powerProduced = 0 # to be updated as nodes send in their power totals: CM
        #self.reqService(minDelay, "sendConsumptionPrediction", None, self.name+"City", 1) #handled already in the initial driver loop
        self.out.write("Time " + str(self.engine.now) + ": Creating " + self.name + " City\n")
    
    def getDifference(self):
        return self.powerProduced - self.powerDraw
        
    def receiveProduction(self, output, *args):
        self.powerProduced = output
        self.out.write("Time " + str(self.engine.now) + ": receiveProduction occuring at " + self.name + " City\n")
        #once production is received, net is passed on
        self.reqService(minDelay, "sendNet", None, self.name+"City", 1)

        
    #this gives an exact value, not randomized, based on the prediction curve
    def predictDraw(self, *args):
        expectedPowerDraw = []
        for time in range(24):
            print time
            fi = (getPop(self.line) * 1000000 * perCapita[getState(self.line)])
            expected = fi/3 * sin(pi/12 * time) + fi
            expectedPowerDraw.append(expected)
        self.out.write("Time " + str(self.engine.now) + ": predictDraw occuring at " + self.name + " City\n")

    #fudges with the expected value to produce what will actually be considered the current consumption in real time
    def updateDraw(self, time, *args):
        fi = (getPop(self.line) * 1000000 * perCapita[getState(self.line)])
        randomBias = random.gauss(1,.1) # the fudge: CM
        self.powerDraw = randomBias * (fi/3 * sin(pi/12 * time) + fi)
        self.out.write("Time " + str(self.engine.now) + ": updateDraw occuring at " + self.name + " City\n")
        #every time it updates actual consumption, it should receive production as well and then send the net
        self.reqService(minDelay, "sendProduction", None, self.name+"Producer", 1)
        
    #sends the expected consumption at each hour to the producers so that they can select the amount of 
    def sendConsumptionPrediction(self, *args):
        self.reqService(minDelay, "receiveConsumptionPrediction", self.expectedPowerDraw, self.name+"Producer", 1)
        self.out.write("Time " + str(self.engine.now) + ": sendConsumptionPrediction occuring at " + self.name + " City\n")
        
    #passes the net consumption of the city to the GridMaster
    def sendNet(self, *args):
        self.reqService(minDelay, "receiveNet", [self.name, self.getDifference()], "GridMaster", 0)
        self.out.write("Time " + str(self.engine.now) + ": sendNet occuring at " + self.name + " City\n")

        

# keeps track of the grid as a whole, likely the subsidy-adding will be implemented here
class GridMaster(Entity):
    def __init__(self, baseInfo):
        super(GridMaster, self).__init__(baseInfo)
        self.net = 0
        self.netDict = {} #this should just have city names and no producer suffix or whatever
        self.netsReceived = 0
        self.out.write("Time " + str(self.engine.now) + ": Creating Gridmaster\n")# could be an error

        
    #accepts the net draw from the individual cities TODO: record the sender with the net in the netList Dictionary
    def receiveNet(self, net, *args):
        self.net += net[1]
        self.netDict[net[0]] = net[1]
        self.netsReceived += 1
        if self.netsReceived == len(citiesList):
            print "wiping net"
            self.out.write("Time " + str(self.engine.now) + ": GridMaster found net excess to be " + str(self.net) + "\n")
            self.reqService(minDelay, "react", None, "GridMaster", 0)
            self.netsReceived = 0
        self.out.write("Time " + str(self.engine.now) + ": receiveNet occuring at GridMaster\n")

            
    #this is called once all of the cities have sent their net consumption
    #it should respond according to this information, redistributing power along the lines necessary, and then reset net
    def react(self, *args):
        for i in self.netDict:
            if self.netDict[i] < 0:
                print "check"
                #findExcess()##define this function to search through connecting lines and find a city with extra power. along the way record the voltage drops along the lines so you know how much power actually can get to the city in question, and if there is a needy city in route, assume that it will consume its needs of whatever power is found down the line
        self.out.write("Time " + str(self.engine.now) + ": react occuring at GridMaster\n")



graph()

#global market curve:
#supply and demand. straightforward
#individual producer: marginal revenue = price, marginal cost swings upward after a certain point.
#^roughly parabolic. let's try making some sort of function for that.
#need to shift it to the right, and we only care about the part that slopes up and where it intersects with the flat line of price
# y = Ax**2 + Bx + C 
# d/dx = 2Ax + B = 0 
#              x = -B/2A
# scrap that. it's hard to shift. for now we'll use a linear model.
# for every $ price increases, quantity increases by .5 kW
#NOTE: these numbers come straight from where the sun don't shine.
#you also have to rearrange how you think about this. You estimate quantity demanded, then select that same quantity to be supplied, then set price accordingly



#extrapolate between the predictions linearly. this is a fair-sized shortcoming, but you haven't even added it yet, so don't worry about that


